<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>Securing Clojure Microservices using buddy - Part 3: Token revocation</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">
    <meta name="keywords" content="">
    <meta name="generator" content="JBake">

    <link href="/blog/css/bootstrap.min.css" rel="stylesheet">
    <link href="/blog/css/asciidoctor.css" rel="stylesheet">
    <link href="/blog/css/base.css" rel="stylesheet">
    <link href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
    <link href="/blog/css/prettify.css" rel="stylesheet">
    <link href='http://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css'>

    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="/js/html5shiv.js"></script>
    <![endif]-->

    <!-- Fav and touch icons -->
    <!--<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/blog/assets/ico/apple-touch-icon-144-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="/blog/assets/ico/apple-touch-icon-114-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="/blog/assets/ico/apple-touch-icon-72-precomposed.png">
    <link rel="apple-touch-icon-precomposed" href="/blog/assets/ico/apple-touch-icon-57-precomposed.png">-->
    <link rel="shortcut icon" href="../favicon.ico">
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-58695124-1', 'auto');
      ga('send', 'pageview');

    </script>
  </head>
  <body onload="prettyPrint()">
    <div id="wrap">

<div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/blog/index.html">Rundis</a>
        </div>
        <div class="navbar-collapse collapse bs-navbar-collapse">
            <ul class="nav navbar-nav">
                <li><a href="/blog/archive.html">Archive</a></li>
                <li><a href="/blog/about.html">About</a></li>
                <li><a href="/blog/feed.xml">Subscribe</a></li>
            </ul>
            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="https://github.com/rundis/blog"><i class="fa fa-lg fa-github"></i></a>
                </li>
            </ul>
        </div>
    </div>
</div>
<div class="container">

	<div class="page-header">
		<h1>Securing Clojure Microservices using buddy - Part 3: Token revocation</h1>
	</div>

	<p><em>19 February 2015</em></p>
  <p><em>Tags: </em>
    <a href="/blog/tags/clojure.html">clojure</a>
  </em>
    <a href="/blog/tags/buddy.html">buddy</a>
  </em>
    <a href="/blog/tags/security.html">security</a>
  </p>
  <a href="https://twitter.com/share" class="twitter-share-button"
    data-url="http://rundis.github.io/blog/2015/buddy_auth_part3.html"
    data-via="mrundberget"
    data-lang="en">Tweet</a>
  <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>

	<p><div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Part 3 in my blog series about securing clojure web services using <a href="https://github.com/funcool/buddy">buddy</a>.
In this episode we&#8217;ll be looking at how we might handle revocation of previously issued auth tokens.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_introduction">Introduction</h2>
<div class="sectionbody">
<div class="ulist">
<div class="title">Previous episodes in this series:</div>
<ul>
<li>
<p><a href="http://rundis.github.io/blog/2015/buddy_auth_part1.html">Securing Clojure Microservices using buddy - Part 1: Creating Auth Tokens</a></p>
</li>
<li>
<p><a href="http://rundis.github.io/blog/2015/buddy_auth_part2.html">Securing Clojure Microservices using buddy - Part 2: WebApp authentication and authorization</a></p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Sample code (tagged for each blog post) can be found on <a href="https://github.com/rundis/acme-buddy">github</a>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In part 2 I said that my next post would be about authorization using tokens in a service application.
Well my conscience got the better of me and I decided I had to address the slightly thorny issue of how to handle
token revocation first. In part 2 I left you in a state where you&#8217;d have a really hard time locking a user out or changing
access rights. You would have to trust that the user re-authenticated (or change the key-pair for token signing/unsigning).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_opposing_forces">Opposing forces</h2>
<div class="sectionbody">
<div class="ulist">
<div class="title">Some of the things we are trying to achieve with our auth design are:</div>
<ul>
<li>
<p>Avoiding session state for authentication and authorization. Hence the introduction of self contained auth tokens</p>
</li>
<li>
<p>The auth service shouldn&#8217;t become a huge dependency magnet, ideally only client facing apps should have to call the auth-service, whilst the service apps would only use the auth-token for authenticating and authorizing requests</p>
</li>
<li>
<p>The user shouldn&#8217;t be prompted for his/her credentials more than necessary</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">The reality though is that:</div>
<ul>
<li>
<p>We have to be able to lock down a user (malicious or whatever reason)</p>
</li>
<li>
<p>We should be able to change a users rights without forcing a re-authentication</p>
</li>
<li>
<p>Checking whether a token has been revoked would be impossible without storing state about that fact somewhere</p>
</li>
<li>
<p>Continuously checking with the auth-service whether a token has been revoked and/or rights have changed with the auth service would negate
the use of tokens in the first place</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_refresh_tokens">Refresh tokens</h2>
<div class="sectionbody">
<div class="paragraph">
<p>I briefly started reading up on <a href="http://tools.ietf.org/html/draft-ietf-oauth-v2-22#section-6">Oath2 Refresh tokens</a>. It have to admin I didn&#8217;t quite get it until I read a farily explanatory post on <a href="http://stackoverflow.com/questions/3487991/why-does-oauth-v2-have-both-access-and-refresh-tokens">stackoverflow</a>.</p>
</div>
<div class="paragraph">
<p>The gist of it that we issue two tokens upon authentication. An authentication token (or access token if you like) and a refresh token.
This allows us to set a shorter expiry for the auth token, and we can use the refresh-token to request a new auth token when a previous one has expired.
The sole purpose of refresh tokens is to be able to request new auth tokens.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_solution_outline">Solution outline</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The diagram below (UML with liberties) illustrates how refresh-tokens might work for us.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/blog/2015//refresh-token.png" alt="refresh token">
</div>
</div>
<div class="olist arabic">
<div class="title">Steps</div>
<ol class="arabic">
<li>
<p>User logs in with username/password</p>
</li>
<li>
<p>The web app invokes the create-auth-token service in acme-auth. This in turn</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>authenticates the user</p>
</li>
<li>
<p>creates an auth-token</p>
</li>
<li>
<p>creates a refresh token</p>
</li>
</ol>
</div>
</li>
<li>
<p>The refresh token is stored in a refresh_tokens table</p>
</li>
<li>
<p>Both the auth-token and refresh-token is returned to the web-app</p>
</li>
<li>
<p>The web app stores the tokens in a cookie which is returned to the browser</p>
</li>
<li>
<p>User makes a request (with a valid auth token)</p>
</li>
<li>
<p>The web app might make a call to a resource server/service app (providing the auth-token as a auth-header in the request)</p>
</li>
<li>
<p>At some point later after the auth-token has expired (say 30 minutes) the user makes another request</p>
</li>
<li>
<p>The web app finds that the auth-token has expired and request a new auth-token using the refresh-token (from the cookie)</p>
</li>
<li>
<p>We retrieve the stored refresh-token to check if it still valid (ie not revoked)</p>
</li>
<li>
<p>We invalidate the existing refresh token in the db (will explain this bit when we look at the implementation)</p>
</li>
<li>
<p>We create a new auth token and a new refresh token. The new refresh token is stored in db</p>
</li>
<li>
<p>A new token-pair is returned to the web-app</p>
</li>
<li>
<p>The web app can now make a request to a resource server/service with a valid auth-token</p>
</li>
<li>
<p>Finally the cookie is updated with the new token-pair</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_where_is_the_code_man">Where is the code man ?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Well that was a long intro, so if you are still following along it&#8217;s time to have a look at what changes and additions
are needed from part 1 and 2.</p>
</div>
<div class="sect2">
<h3 id="_changing_token_creation_in_acme_auth">Changing token creation in acme-auth</h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cloure" data-lang="cloure">(defn- unsign-token [auth-conf token]
  (jws/unsign token (pub-key auth-conf)))

(defn- make-auth-token [auth-conf user]                                        <i class="conum" data-value="1"></i><b>(1)</b>
  (let [exp (-&gt; (t/plus (t/now) (t/minutes 30)) (jws/to-timestamp))]
    (jws/sign {:user (dissoc user :password)}
              (priv-key auth-conf)
              {:alg :rs256 :exp exp})))

(defn- make-refresh-token! [conn auth-conf user]                               <i class="conum" data-value="2"></i><b>(2)</b>
  (let [iat (jws/to-timestamp (t/now))
        token (jws/sign {:user-id (:id user)}
                        (priv-key auth-conf)
                        {:alg :rs256 :iat iat :exp (-&gt; (t/plus (t/now) (t/days 30)) (jws/to-timestamp))})]

    (store/add-refresh-token! conn {:user_id (:id user)                        <i class="conum" data-value="3"></i><b>(3)</b>
                                    :issued iat
                                    :token token})
    token))

(defn make-token-pair! [conn auth-conf user]                                   <i class="conum" data-value="4"></i><b>(4)</b>
  {:token-pair {:auth-token (make-auth-token auth-conf user)
                :refresh-token (make-refresh-token! conn auth-conf user)}})


(defn create-auth-token [ds auth-conf credentials]                             <i class="conum" data-value="5"></i><b>(5)</b>
  (jdbc/with-db-transaction [conn ds]
    (let [[ok? res] (auth-user conn credentials)]
      (if ok?
        [true (make-token-pair! conn auth-conf (:user res))]
        [false res]))))</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The auth token store user and role info as in part 1, but we now have the option of shortening the expiry</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>For simplicity we have created the refresh token using the same key-pair as for the auth token. The refresh token
contains only user-id and issued at time (iat). This allows us retrieval of the db stored token info later on. The expiry for this token can be as long as you are comfortable with (30 days in this instance)</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>We store the token in the refresh_token table with some fields extracted for ease of querying</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>We now return a map with both the auth-token and our shiny new refresh-token</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>The entry point service for token creation</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_refreshing_tokens">Refreshing tokens</h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure" data-lang="clojure">(defn refresh-auth-token [ds auth-conf refresh-token]
  (if-let [unsigned (unsign-token auth-conf refresh-token)]                                               <i class="conum" data-value="1"></i><b>(1)</b>
    (jdbc/with-db-transaction [conn ds]
      (let [db-token-rec (store/find-token-by-unq-key conn (:user-id unsigned) (:iat unsigned))           <i class="conum" data-value="2"></i><b>(2)</b>
            user (store/find-user-by-id conn (:user_id db-token-rec))]
        (if (:valid db-token-rec)                                                                         <i class="conum" data-value="3"></i><b>(3)</b>
          (do
            (store/invalidate-token! conn (:id db-token-rec))                                             <i class="conum" data-value="4"></i><b>(4)</b>
            [true (make-token-pair! conn auth-conf user)])                                                <i class="conum" data-value="5"></i><b>(5)</b>
          [false {:message "Refresh token revoked/deleted or new refresh token already created"}])))
    [false {:message "Invalid or expired refresh token provided"}]))</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We unsign the refresh-token to ensure it is valid (not tampered with or expired)</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We use information from the refresh token to retrieve it&#8217;s db stored representation.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>This test could return false for 3 cases; token deleted, token has been revoked or the token has been invalidated because a new refresh token has been created</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The existing refresh token is invalidated in the database</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>We create a new token pair (where the newly created refresh token is stored in a new db row in the refrest_token table)</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Why creating a new refresh token every time ?</div>
<div class="paragraph">
<p>Imagine that someone gets hold of a users refresh token. Lets say the user requests a token refresh first, now if the hijacker
is making a refresh-request with the hijacked request token we detect that a refresh is attempted on a token that is already invalid.
We can&#8217;t tell if the user or the hijacker is first, but either way we could take action (trigger warning/lock user account etc)
In the code above we can&#8217;t tell the diffence between why a refresh token is invalid, so you might wish to have a separate flag for this particular check.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_middleware_changes_in_the_acme_webstore">Middleware changes in the acme-webstore</h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-clojure" data-lang="clojure">(defn wrap-auth-cookie [handler cookie-secret]                                    <i class="conum" data-value="1"></i><b>(1)</b>
  (-&gt; handler
      (wrap-session
       {:store (cookie-store {:key cookie-secret})
        :cookie-name "acme"
        :cookie-attrs {:max-age (* 60 60 24 30)}}))) ;; you should probably add :secure true to enforce https


(defn unsign-token [token]
  (jws/unsign token (ks/public-key (io/resource "auth_pubkey.pem"))))


(defn wrap-auth-token [handler]                                                  <i class="conum" data-value="2"></i><b>(2)</b>
  (fn [req]
    (let [auth-token (-&gt; req :session :token-pair :auth-token)
          unsigned-auth (when auth-token (unsign-token auth-token))]
      (if unsigned-auth
        (handler (assoc req :auth-user (:user unsigned-auth)))
        (handler req)))))

(defn- handle-token-refresh [handler req refresh-token]
  (let [[ok? res] (refresh-auth-token refresh-token)                             <i class="conum" data-value="4"></i><b>(4)</b>
        user (:user (when ok? (unsign-token (-&gt; res :token-pair :auth-token))))]
    (if user
      (-&gt; (handler (assoc req :auth-user user))                                  <i class="conum" data-value="5"></i><b>(5)</b>
          (assoc :session {:token-pair (:token-pair res)}))
      {:status 302
       :headers {"Location " (str "/login?m=" (:uri req))}})))                   <i class="conum" data-value="6"></i><b>(6)</b>

(defn wrap-authentication [handler]
  (fn [req]
    (if (:auth-user req)
      (handler req)
      (if-let [refresh-token (-&gt; req :session :token-pair :refresh-token)]
        (handle-token-refresh handler req refresh-token)                         <i class="conum" data-value="3"></i><b>(3)</b>
          {:status 302
           :headers {"Location " (str "/login?m=" (:uri req))}}))))</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The only change we made to the cookie middleware is increase the ttl.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The wrap-auth-token middleware just needed to change to handle that auth-token is found as part of a token pair
(not shown: the login handler adds the token pair to the session upon successful authentication)</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>If the auth token has expired and refresh token exists we initiate an attempt to refresh the token pair</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Invokes the acme-auth service for requesting token refresh</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>If a refreshing the token pair was successful we invoke the next handler in the chain and assoc the new token pair with the session key in the response
(which in turn ends up in the cookie)</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>We give up, you have to log in again</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
It might not be a great ideat to store the auth token and the refresh token in the same cookie. Haven&#8217;t really
thought that bit through tbh.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_summary">Summary</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A lot of thinking and not a lot of code this time. But I feel we have come up with a solution that might provide a suitable
balance between risk and statelessless with regards to revoking tokens/user access. Refresh tokens
allows us to stay clear of sessions and avoid asking the usere for their credentials.  <a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet">CSRF</a>
is obviously still an issue, but we have taken some small steps to detect when the users cookie might have been hijacked.</p>
</div>
<div class="paragraph">
<p>The next episode will definately be about authentication and authorization in a service app.</p>
</div>
</div>
</div></p>

  <div id="disqus_thread"></div>
    <script type="text/javascript">
        var disqus_shortname = 'rundis';
	      var disqus_identifier = 'buddy_auth_part3';
        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
	<hr />

		</div>
		<div id="push"></div>
    </div>

    <div id="footer">
      <div class="container">
        <p class="muted credit">&copy; 2015 Magnus Rundberget
          <a class="pull-right btn btn-xs" href="https://twitter.com/mrundberget"><i class="fa fa-twitter"></i></a>
          <a class="pull-right btn btn-xs" href="https://github.com/rundis"><i class="fa fa-github"></i></a>
          <a class="pull-right btn btn-xs" href="http://no.linkedin.com/in/mrundberget"><i class="fa fa-linkedin"></i></a>
        </p>
      </div>
    </div>

    <script src="../js/jquery-1.11.1.min.js"></script>
    <script src="../js/bootstrap.min.js"></script>
    <script src="../js/prettify.js"></script>
  </body>
</html>
